// Generated by CoffeeScript 1.10.0
(function() {
  var d3, defaults, styleAxis, uuid, xaxis, yaxis;

  uuid = require('uuid');

  d3 = require('d3');

  defaults = {
    neatline: true
  };

  styleAxis = function(g) {
    g.selectAll('path.domain').attr({
      fill: 'none',
      stroke: 'black'
    });
    return g.selectAll('.tick line').attr({
      stroke: '#000000'
    });
  };

  xaxis = function(ax) {
    var _y, g, k, label, labelOffset, labelSize, tickOffset, v, y;
    g = null;
    label = null;
    tickOffset = 10;
    labelSize = 10;
    labelOffset = 22;
    _y = d3.svg.axis();
    y = function() {
      g = d3.select(this).append("g").attr({
        "class": "x axis"
      });
      g.append("text").attr({
        "class": 'label'
      }).style({
        'text-anchor': "middle"
      }).text(label);
      g.call(_y);
      g.call(styleAxis);
      return y.update();
    };
    y.update = function() {
      var sz;
      sz = ax.plotArea.size();
      g.attr({
        transform: "translate(0," + sz.height + ")"
      });
      g.select('text.label').attr({
        transform: "translate(" + (sz.width / 2) + ",0)",
        'font-size': labelSize,
        dy: labelOffset
      });
      g.selectAll(".tick text").attr({
        'text-anchor': "middle",
        "font-size": 10
      });
      if (ax.grid()) {
        return g.selectAll('.tick .grid').attr({
          x1: sz.height
        });
      }
    };
    y.tickOffset = function(d) {
      if (d == null) {
        return tickOffset;
      }
      tickOffset = d;
      return y;
    };
    y.label = function(d) {
      if (d == null) {
        return label;
      }
      label = d;
      return y;
    };
    y.labelOffset = function(d) {
      if (d == null) {
        return labelOffset;
      }
      labelOffset = d;
      return y;
    };
    for (k in _y) {
      v = _y[k];
      y[k] = v;
    }
    y.scale(ax.scale.x);
    y.orient("bottom");
    return y;
  };

  yaxis = function(ax) {
    var _despined, _y, g, k, label, labelOffset, labelSize, tickOffset, v, y;
    g = null;
    label = null;
    labelSize = 10;
    labelOffset = 20;
    tickOffset = 10;
    _despined = false;
    _y = d3.svg.axis();
    y = function() {
      g = d3.select(this).append("g").attr({
        "class": "y axis"
      });
      g.append("text").attr({
        "class": 'label',
        dy: -labelOffset
      }).style({
        'text-anchor': "middle"
      }).text(label);
      if (!_despined) {
        g.call(_y).call(styleAxis);
      }
      return y.update();
    };
    y.update = function() {
      var right, rot, sz;
      sz = ax.plotArea.size();
      right = y.orient() === 'right';
      rot = 90;
      if (!right) {
        rot *= -1;
      }
      g.select('text.label').attr({
        transform: "translate(0," + (sz.height / 2) + ")rotate(" + rot + ")",
        'font-size': labelSize
      });
      g.selectAll(".tick text").attr({
        'text-anchor': "middle",
        "font-size": 10
      });
      if (ax.grid()) {
        g.selectAll('.tick .grid').attr({
          x1: sz.width
        });
      }
      if (right) {
        return g.attr({
          transform: "translate(" + sz.width + ",0)"
        });
      }
    };
    y.tickOffset = function(d) {
      if (d == null) {
        return tickOffset;
      }
      tickOffset = d;
      return y;
    };
    y.label = function(d) {
      if (d == null) {
        return label;
      }
      label = d;
      return y;
    };
    y.labelOffset = function(d) {
      if (d == null) {
        return labelOffset;
      }
      labelOffset = d;
      return y;
    };
    y.despine = function() {
      _despined = true;
      return y;
    };
    for (k in _y) {
      v = _y[k];
      y[k] = v;
    }
    y.scale(ax.scale.y);
    y.orient("left");
    return y;
  };

  module.exports = function(opts) {
    var C, __update, _clip, _grid, _neatline, _xax, _yax, ax, axTrans, graticule, innerSize, k, line, margin, neatline, node, o, offset, scales, size, x, y;
    if (opts == null) {
      opts = {};
    }
    for (k in defaults) {
      o = defaults[k];
      if (k in opts) {
        continue;
      }
      opts[k] = o;
    }
    C = null;
    size = {
      width: 500,
      height: 300
    };
    offset = {
      x: 0,
      y: 0
    };
    axTrans = null;
    margin = 0;
    innerSize = null;
    _grid = true;
    _neatline = false;
    _clip = false;
    node = null;
    ax = null;
    neatline = null;
    graticule = null;
    _xax = null;
    _yax = null;
    x = d3.scale.linear();
    y = d3.scale.linear();
    scales = {
      x: x,
      y: y
    };
    line = function(opts) {
      var l, type;
      if (opts == null) {
        opts = {};
      }
      l = d3.svg.line();
      type = opts.type || 'array';
      if (type === 'array') {
        l.x(function(d) {
          return C.scale.x(d[0]);
        });
        l.y(function(d) {
          return C.scale.y(d[1]);
        });
      } else if (type === 'object') {
        l.x(function(d) {
          return C.scale.x(d.x);
        });
        l.y(function(d) {
          return C.scale.y(d.y);
        });
      }
      if (opts.interpolate != null) {
        l.interpolate(opts.interpolate);
      }
      return l;
    };
    __update = function() {
      var h, w;
      w = size.width - margin.left - margin.right;
      h = size.height - margin.top - margin.bottom;
      innerSize = {
        width: w,
        height: h
      };
      axTrans = {
        x: offset.x + margin.left,
        y: offset.y + margin.top
      };
      C.scale.x.range([0, innerSize.width]);
      C.scale.y.range([innerSize.height, 0]);
      if (_xax != null) {
        _xax.update();
      }
      if (_yax != null) {
        return _yax.update();
      }
    };
    C = function(el) {
      var areaID, axContainer, clipID, defs;
      node = el.node();
      defs = el.append('defs');
      areaID = uuid.v1();
      clipID = uuid.v1();
      defs.append('rect').attr(innerSize).attr({
        id: areaID,
        x: 0,
        y: 0
      });
      defs.append('clipPath').attr({
        id: clipID
      }).append('use').attr({
        'xlink:href': "#" + areaID
      });
      axContainer = el.append('g').attr({
        transform: " translate(" + axTrans.x + "," + axTrans.y + ")"
      }).attr(innerSize);
      graticule = axContainer.append('g');
      ax = axContainer.append('g');
      if (_clip) {
        ax.attr({
          'clip-path': "url(#" + clipID + ")"
        });
      }
      if (_neatline) {
        neatline = axContainer.append('use').attr({
          'xlink:href': "#" + areaID,
          "class": 'neatline',
          stroke: 'black',
          fill: 'transparent'
        });
      }
      if (_xax != null) {
        _xax.call(graticule.node());
      }
      if (_yax != null) {
        return _yax.call(graticule.node());
      }
    };
    C.axes = {
      x: function() {
        if (_xax == null) {
          _xax = xaxis(C);
        }
        return _xax;
      },
      y: function() {
        if (_yax == null) {
          _yax = yaxis(C);
        }
        return _yax;
      }
    };
    C.grid = function(g) {
      if (g != null) {
        _grid = g;
        return C;
      } else {
        return _grid;
      }
    };
    C.node = function() {
      return node;
    };
    C.plotArea = function() {
      return ax;
    };
    C.plotArea.size = function() {
      return innerSize;
    };
    C.neatline = function(v) {
      if (v == null) {
        v = true;
      }
      _neatline = v;
      _clip = v;
      return C;
    };
    C.clip = function(v) {
      if (v == null) {
        v = true;
      }
      _clip = v;
      return C;
    };
    C.graticule = function() {
      return graticule;
    };
    C.line = line;
    C.boundingBox = function() {
      return {
        left: offset.x,
        top: offset.y,
        bottom: offset.y + size.height,
        right: offset.x + size.width
      };
    };
    C.size = function(d) {
      var v;
      if (d == null) {
        return size;
      }
      for (k in size) {
        v = size[k];
        if (k in d) {
          size[k] = d[k];
        }
      }
      __update();
      return C;
    };
    C.margin = function(d) {
      if (d == null) {
        return margin;
      }
      if (d.left != null) {
        margin = d;
      } else {
        margin = {
          left: d,
          right: d,
          top: d,
          bottom: d
        };
      }
      __update();
      return C;
    };
    C.scale = scales;
    C.position = function(p) {
      var v;
      if (p == null) {
        return offset;
      }
      for (k in offset) {
        v = offset[k];
        if (k in p) {
          offset[k] = p[k];
        }
      }
      __update();
      return C;
    };
    C.reflow = __update;
    C.margin(50);
    __update();
    return C;
  };

}).call(this);
